<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/09/10/JDBC/"/>
    <url>/2022/09/10/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC学习记录"><a href="#JDBC学习记录" class="headerlink" title="JDBC学习记录"></a>JDBC学习记录</h1><blockquote><p>内容源于B站：<a href="https://www.bilibili.com/video/BV1zv41157NC?p=37&amp;spm_id_from=pageDriver&amp;vd_source=d03a2a917e41a2c7fe6e9dfad567efc2">https://www.bilibili.com/video/BV1zv41157NC?p=37&amp;spm_id_from=pageDriver&amp;vd_source=d03a2a917e41a2c7fe6e9dfad567efc2</a> 老师讲的很不错，<del>但是稍微有一点点啰嗦了</del>，所以记录一下精华部分</p></blockquote><h2 id="理解JDBC"><a href="#理解JDBC" class="headerlink" title="理解JDBC"></a>理解JDBC</h2><p>JDBC是java规定的一系列接口，数据库厂商完成JDBC的一系列接口实现类并打包为.jar作为JDBC的驱动程序。java程序通过引入的特定数据库驱动程序进行API调用以连接、访问和操作数据库。</p><p>与数据库有关的接口定义在java的java.sql和javax.sql两个package里面。点击<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/module-summary.html">链接</a>查询Oracle官方的接口文档。</p><p>MySql、Oracle等数据库均实现了JDBC的API要求，相关jar包可以通过网络下载（或者去我的github仓库找），将驱动加入项目依赖即可使用JDBC接口提供的方式对数据库进行操作。</p><p><img src="/2022-09-09-23-14-24.png"></p><p>如果发现这个驱动还是无法引用，在Project Structure-&gt;module中勾选相应的包即可</p><p><img src="/2022-09-09-23-16-31.png"></p><h2 id="连接与操作数据库"><a href="#连接与操作数据库" class="headerlink" title="连接与操作数据库"></a>连接与操作数据库</h2><p>在引入驱动之后，即可根据JDBC方式连接到数据库并对其进行相关操作。</p><h3 id="基本连接方法"><a href="#基本连接方法" class="headerlink" title="基本连接方法"></a>基本连接方法</h3><p>一般步骤为：</p><ol><li>注册驱动</li><li>连接数据库（提供url、username、password）</li><li>驱动实例建立连接（socket网络连接）</li><li>执行一系列数据库操作的sql命令</li><li>关闭连接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 注册驱动</span><br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br> <br><span class="hljs-comment">//2. 将用户名和密码写入到Properties对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/school_test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">url:</span><br><span class="hljs-comment">jdbc:表示连接方式的协议，采用jdbc接口连接数据库</span><br><span class="hljs-comment">localhost:本机,ip地址</span><br><span class="hljs-comment">3306:mysql监听的端口</span><br><span class="hljs-comment">school_test:mysql中所要连接的数据库</span><br><span class="hljs-comment">?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true:说明了一系列属性，其中如果不加useSSL=false会报错显示访问被拒绝，serverTimezone=Asia/Shanghai也必须加上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>); <span class="hljs-comment">//key-value</span><br>properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;******&quot;</span>); <span class="hljs-comment">//key-value</span><br><br><span class="hljs-comment">//3. 根据给定的url连接数据库（connect接收url及Properties info作为输入)</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> driver.connect(url,properties); <span class="hljs-comment">//获取连接 socket网络连接</span><br><br><span class="hljs-comment">//4. 执行sql命令</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(null,&#x27;zjh&#x27;,110)&quot;</span>;<br><span class="hljs-comment">//定义了一个sql语句</span><br><span class="hljs-comment">//statement用于执行静态的SQL语句 向数据库提供并执行操作语句，得到返回结果</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql); <span class="hljs-comment">//如果是dml 返回影响行数</span><br><br>sql = <span class="hljs-string">&quot;update student set name=&#x27;zjh&#x27; where id=1&quot;</span>; <span class="hljs-comment">//更新命令</span><br>rows = statement.executeUpdate(sql);<br><br>System.out.println(rows&gt;<span class="hljs-number">0</span>?<span class="hljs-string">&quot;成功&quot;</span>:<span class="hljs-string">&quot;失败&quot;</span>);<br><br><span class="hljs-comment">//5. close 及时关闭连接</span><br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li>动态加载驱动类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态加载(反射类名) 不用再import 某个类了</span><br>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver)aClass.newInstance();<br></code></pre></td></tr></table></figure></li><li>使用Java.sql package中的驱动管理类统一管理驱动对象并建立连接（由DriverManager对象而非Driver对象获取连接，无需Properties传值） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 反射加载驱动类</span><br>Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> (Driver) aClass.newInstance();<br><span class="hljs-comment">//2. 直接传值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zjh&quot;</span>;<br>DriverManager.registerDriver(driver); <br><span class="hljs-comment">//DriverManager进行注册驱动并获得连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br></code></pre></td></tr></table></figure> 或者上面的代码可以简化为 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="hljs-comment">//jdbc自动在META-INF中的文本中的类名称去注册</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;root&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zjh&quot;</span>;<br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br></code></pre></td></tr></table></figure></li><li>读取配置文件，灵活传参<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">20030816zjh</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/school_test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure>新建src\mysql.properties文件并写入上述内容<br>则可以通过如下方式连接到数据库<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 读取配置文件</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br><br><span class="hljs-comment">//加载， 注册，连接</span><br>Class&lt;?&gt; aClass = Class.forName(driver);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,user,password);<br></code></pre></td></tr></table></figure></li></ol><p>PS：</p><ol><li>上面提到的connection、statement均为驱动程序中实现了JDBC接口的对象</li><li>获取连接后在不需要连接时应该及时关闭，否则会引起系统资源泄露和服务器崩溃</li></ol><h3 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h3><p>数据库基本操作crud，进一步可分为query和DML。</p><p>执行sql语句的流程是：</p><ol><li>由connection创建Statement对象</li><li>向Statement对象传入<strong>静态</strong>sql语句并执行，获取返回结果</li></ol><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><blockquote><p>A table of data representing a database result set, which is usually generated by executing a statement that queries the database.</p></blockquote><p>Statement对象执行查询语句时获得结果以结果集（ResultSet）的形式返回，结果集的查看类似于一个iterator，通过next()移动光标。</p><p>结果集获取具体内容是通过next()定位行和getXXX()方法定位列来实现的(其中XXX表示返回类型)。</p><p>查询语句通过executeQuery()执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, name, age from student&quot;</span>;<br>ResultSet resultSet=statement.executeQuery(sql);<span class="hljs-comment">//得到一个单个的查询的结果集</span><br><span class="hljs-comment">// while循环取出数据</span><br><br><span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>    <span class="hljs-comment">//类似iterator 让光标向后移动，如果没有更多行则返回false</span><br>    <span class="hljs-type">int</span> id=resultSet.getInt(<span class="hljs-number">1</span>);<span class="hljs-comment">//获取该行的第一列，参数表示列</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-number">2</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span>resultSet.getString(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> resultSet.getDate(<span class="hljs-number">4</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此外previous()方法用于光标回退，close()方法用于关闭结果集（当connection关闭后，即使ResultSet没有执行close()也依然会失效）</p><p>在查看完毕后，依次关闭resultSet、statement、connection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>statement（或是preparedStatement）执行DML语句后，会返回收到影响的行数（元组数），可用于判断是否对表产生影响。DML语句通过executeUpdate()执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">sql = <span class="hljs-string">&quot;update student set name=&#x27;zjh&#x27; where id=1&quot;</span>;<br><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql); <br></code></pre></td></tr></table></figure><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><blockquote><p>description of Statement in  package java.sql:<br>The object used for executing a static SQL statement and returning the results it produces.<br>By default, only one ResultSet object per Statement object can be open at the same time. Therefore, if the reading of one ResultSet object is interleaved with the reading of another, each must have been generated by different Statement objects. All execution methods in the Statement interface implicitly close a current ResultSet object of the statement if an open one exists.</p></blockquote><p>Statement是java.sql中定义的一个接口，用于执行静态的SQL语句并返回结果。默认下，每个Statement对象只能同时打开一个ResultSet对象</p><p>Statement的缺点是无法执行动态的SQL（只能通过字符串拼接来获取相关参数值），这会导致一个非常严重的问题——sql注入。</p><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;请输入用户名和密码&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">admin_name</span> <span class="hljs-operator">=</span> scanner.nextLine(); <span class="hljs-comment">// 1&#x27; or</span><br><span class="hljs-type">String</span> <span class="hljs-variable">admin_pwd</span> <span class="hljs-operator">=</span> scanner.nextLine(); <span class="hljs-comment">//or &#x27;1&#x27; = &#x27;1</span><br><span class="hljs-comment">//上述为万能密码，其实是因为和sql的语句犯冲了</span><br><span class="hljs-comment">//如果希望看到Sql注入 则需要使用nextline 否则在接受空格时结束</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, pwd from admin where name=&#x27;&quot;</span>+admin_name+<span class="hljs-string">&quot;&#x27;and pwd =&#x27;&quot;</span>+admin_pwd+<span class="hljs-string">&quot;&#x27;&quot;</span>;<br>ResultSet resultSet=statement.executeQuery(sql); <span class="hljs-comment">//查询命令</span><br><span class="hljs-keyword">if</span> (resultSet.next())&#123;<br>    <span class="hljs-comment">//如果查询到记录，证明该管理存在</span><br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;fail&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//close all</span><br></code></pre></td></tr></table></figure><p>为了解决sql注入问题，引入了PreparedStatement，可以传入SQL命令的参数。同时减少了编译次数，提高了效率</p><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><blockquote><p>description:<br>An object that represents a precompiled SQL statement.<br>A SQL statement is precompiled and stored in a PreparedStatement object. This object can then be used to efficiently execute this statement multiple times.</p></blockquote><p>在PreparedStatement中，SQL语句被预编译并存储在PreparedStatement对象中。编译一次，执行多次。执行效率相较Statement有所提高（statement是编译一次执行一次）。</p><p>PreparedStatement继承自Statement，在其基础上主要增加了一系列的传参方法，比如setInt,setString等。使用方法也很简单，在sql命令中用?作为占位符表示要传入的参数，传入sql初始化PreparedStatement并设置参数即可执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, pwd from admin where name=? and pwd =? &quot;</span>;<br><span class="hljs-comment">//问号相当于占位符</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br><span class="hljs-comment">//给问号赋值</span><br>preparedStatement.setString(<span class="hljs-number">1</span>,admin_name);<br>preparedStatement.setString(<span class="hljs-number">2</span>,admin_pwd);<br><br>ResultSet resultSet=preparedStatement.executeQuery();<br><span class="hljs-comment">//执行查询的时候不要在括号里传参sql 否则会传入带问号的那个sql命令 就会错误，硬编码的可以</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//close all</span><br></code></pre></td></tr></table></figure><p>这部分看完了可以直接跳去ResultSet的<a href="#%E7%A8%8B%E5%BA%8F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84resultset%E4%BC%98%E5%8C%96">优化</a></p><h2 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h2><p>实际上这是一个自定义的工具类。(<del>所以可以跳过</del>)</p><p>考虑到在代码中常常用到properties的读取、数据库的连接和关闭，我们可以做一个简单的工具类集成这些功能。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性主要是私有的静态数据库连接属性，在静态代码块（类加载时唯一执行）中初始化。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法主要包括获取连接和关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCutils</span> &#123;<br>    <span class="hljs-comment">//工具类 完成mysql的连接和关闭资源 代码复用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String user;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br>            <span class="hljs-comment">//读取相关的属性</span><br>            user = properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>            password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">//实际开发中 将编译异常转成运行异常 调用者可以选择捕获 也可以选择默认处理</span><br>            <span class="hljs-comment">//因为这是一个工具类</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> DriverManager.getConnection(url,user,password);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet set, Statement statement,Connection connection)</span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 结果集</span><br><span class="hljs-comment">        2. Statement或者PreparedStatement</span><br><span class="hljs-comment">        3.connection</span><br><span class="hljs-comment">        4. 如果需要关闭资源就传入对象，否则传入空</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//判断是否为空</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (set != <span class="hljs-literal">null</span>) &#123;<br>                set.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (statement != <span class="hljs-literal">null</span>) &#123;<br>                statement.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>                connection.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以稍微关注一下方法中对于异常的处理，在getConnection中，DriverManager.getConnection方法会抛出SQLException，这里我们不选择简单地抛出异常，而是将编译异常转为运行异常(RuntimeException)，调用者可以选择捕获。</p><p>当然目前的Utils工具类还非常初步，后面会慢慢添加功能的</p><ol><li>连接池 </li><li>datasource</li></ol><h2 id="事务和批处理"><a href="#事务和批处理" class="headerlink" title="事务和批处理"></a>事务和批处理</h2><p>在实际对于SQL的操作中，我们常常会一次性执行若干命令，而且只有这些命令均执行成功时才视作此次操作成功。</p><p>例如，对于转账操作，我们需要同时更改两个用户的余额（减小A的余额；增加B的余额），在此过程中，若第一步成功而第二次不成功，视为失败，需要<strong>回滚</strong>到两个命令都未执行的状态。</p><p>默认情况下，Statement对象接收到一个SQL语句会自动提交事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);<br></code></pre></td></tr></table></figure><p>以下为java.sql中Connection接口中commit()方法的部分描述</p><blockquote><p>Makes all changes made since the previous commit&#x2F;rollback permanent and releases any database locks currently held by this <code>Connection</code> object. This method should be used only when auto-commit mode has been disabled.</p></blockquote><p>以及对auto-commit模式的描述</p><blockquote><p>Sets this connection’s auto-commit mode to the given state.<br>If a connection is in auto-commit mode, then all its SQL statements will be executed and committed as individual transactions.  Otherwise, its SQL statements are grouped into  transactions that are terminated by a call to either  the method <code>commit</code> or the method <code>rollback</code>.<br>By default, new connections are in auto-commit mode.</p></blockquote><p>翻译成人话大概就是：connection是船舶管理局的，statement是船夫，sql语句是乘客。一个execute过程是一个乘客到达了船夫的船上，默认情况下船舶管理局让船夫立马开船到达数据库让sql干活，所以execute完sql自动就到数据库了。但是禁止auto-commit的时候，船舶管理局要求船夫不能来人就走，得给局里提交申请，申请完了才能走。这个时候船夫可以等好几个人都上船了才交申请，也就是commit方法。<br>（上面的比喻可能有些地方不恰当，结合代码理解一下大概就差不多了）</p><p>采用事务可以提高程序效率，这是很朴素的：发送和执行sql是一次socket连接，会损耗一定时间，频繁进行网络连接会大大降低程序效率。</p><p>为了解决这种一次一发的效率问题，人们提出了批量管理的方法。</p><p>一般是把批处理和PreparedStatement相结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.setAutoCommit(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5000</span>;i++)&#123;<br>    preparedStatement.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;jack&quot;</span>+i);<br>    preparedStatement.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;666&quot;</span>);<br>    preparedStatement.executeUpdate();<br>    preparedStatement.addBatch();<br>    <span class="hljs-comment">//当有100条记录时进行批量执行</span><br>    <span class="hljs-keyword">if</span> ((i+<span class="hljs-number">1</span>)%<span class="hljs-number">1000</span>==<span class="hljs-number">0</span>)&#123;<br>        preparedStatement.executeBatch();<br>        <span class="hljs-comment">//执行后情况</span><br>        connection.commit();<br>        preparedStatement.clearBatch();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>另外在mysql.properties中增加属性<code>rewriteBatchedStatements=true</code>可以实现高性能的批量插入</p><blockquote><p>MySQL JDBC驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，批量插入实际上是单条插入，直接造成较低的性能。<br>只有把rewriteBatchedStatements参数置为true, 驱动才会帮你批量执行SQL另外这个选项对INSERT&#x2F;UPDATE&#x2F;DELETE都有效<br>ref: <a href="http://events.jianshu.io/p/1eeb517c6ce7">http://events.jianshu.io/p/1eeb517c6ce7</a></p></blockquote><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>在传统的连接方式中会出现这样一个问题：一个程序有时候会频繁获取connection。首先已知获取了connection要及时关闭（不关闭会可能会导致数据库崩溃），但频繁申请和关闭connction仍然会给数据库系统带来巨大的压力和潜在的风险。</p><p>因此引入了数据库连接池技术，大概思想就是限制一个程序可获取的连接数，请求数大于连接池中的连接数时该请求进入等待队列。</p><p>数据库连接池中的一个<strong>重要概念</strong>是对close的理解，Druid执行close并不是真的断开connection与数据库之间的连接，而是取消当前Connection对象对连接池元素的引用。</p><p>目前数据库连接池技术比较常用的是Druid（集大成者）</p><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><p>Druid连接池的使用基本如下：</p><ol><li><p>加入jar包</p><p> <img src="/2022-09-10-01-47-56.png"></p></li><li><p>加入properties配置文件</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/school_test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">20030816zjh</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">10</span><br><span class="hljs-comment">#最少连接数（如果发现没有那么多需求就适当关几个连接，最少留5个）</span><br><span class="hljs-attr">minIdle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment">#最多连接数（如果一开始开了10个，发现需求太多了，可以多开几个，最多20个）</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">20</span><br><span class="hljs-comment">#最大等待时间（一个请求在等待队列里最多等5s，如果过了5s还没等到就认为请求失败并返回）</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure></li><li><p>创建Properties对象读取配置文件</p></li><li><p>根据配置创建连接池</p></li><li><p>获取连接 </p></li><li><p>关闭连接</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_druid_1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//1.加入依赖包</span><br>    <span class="hljs-comment">//2. 加入配置文件</span><br>    <span class="hljs-comment">//3.创建properties对象，读取配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br><br>    <span class="hljs-comment">//4. 创建一个连接池对象 工厂模式，根据配置获取数据源</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(properties);<br><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>    connection.close();<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="Druid连接池基础上的工具类优化"><a href="#Druid连接池基础上的工具类优化" class="headerlink" title="Druid连接池基础上的工具类优化"></a>Druid连接池基础上的工具类优化</h3><p>就是单纯地用连接池方法进行连接了而已，不想看就跳吧）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCUtilsByDruid</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于Druid数据库连接池的工具类</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//获取一个数据源（初始化一个连接池</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src\\druid.properties&quot;</span>));<br>            ds = DruidDataSourceFactory.createDataSource(properties);<br>        &#125;  <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//懒得再写抛出运行异常了，会抛出一个runtimeerror</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> ds.getConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(ResultSet resultSet, Statement statement,Connection connection)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">if</span> (resultSet!=<span class="hljs-literal">null</span>)&#123;<br>            resultSet.close();<br>        &#125;<span class="hljs-keyword">if</span>(statement!=<span class="hljs-literal">null</span>)&#123;<br>            statement.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(connection!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//这里的connection实际是一个Druid内部的一个实现了JDBC接口的一个类，所以它的一切操作都内置在Druid里面</span><br>            connection.close();  <span class="hljs-comment">//这里close只是还给缓冲池，依赖于Druid内部的close实现</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="程序对象与数据库对象之间的映射——ResultSet优化"><a href="#程序对象与数据库对象之间的映射——ResultSet优化" class="headerlink" title="程序对象与数据库对象之间的映射——ResultSet优化"></a>程序对象与数据库对象之间的映射——ResultSet优化</h3><p>ResultSet存在的一个问题是：它紧紧依赖于statement和connection，一旦二者中有一个关闭，就无法再对结果集进行访问，为此需要将ResultSet的结果映射为java程序内部的一个实例对象（<strong>domain</strong>层)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个映射关系大概是这样的</span><br>set = preparedStatement.executeQuery();<br>ArrayList&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Student&gt;();<br><span class="hljs-keyword">while</span> (set.next())&#123;<br>    <span class="hljs-comment">//遍历结果集 封装到student对象</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> set.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> set.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> set.getInt(<span class="hljs-string">&quot;age&quot;</span>);<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(id,name,age));<span class="hljs-comment">//这个新的和connection没有任何关系 可以脱离connection而存在</span><br>&#125;<br></code></pre></td></tr></table></figure><p>apache-DBUtils工具类封装了这一过程（同时无需使用PreparedStatement,QueryRunner解决一切），使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> JDBCUtilsByDruid.getConnection();<br><span class="hljs-type">QueryRunner</span> <span class="hljs-variable">queryRunner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryRunner</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from student where id &gt;= ?&quot;</span>;<br>List&lt;Student&gt; list  =  queryRunner.query(connection, sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanListHandler</span>&lt;&gt;(Student.class), <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>重点在于query()方法中传入的对象，当结果是集合时，new一个BeanListHandler&lt;&gt;(Student.class),类似地，当结果是单行时，new一个BeanHandler&lt;&gt;()即可，方法相应地也返回一个Student对象。当结果是单个值时，new一个ScalarHandler对象（无参），返回一个Object。</p><p>query()方法最后的参数是一个未定参数，用于给sql传参。</p><h2 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h2><p>domain域完成数据库对象和程序对象之间的映射（数据库元素的表达），DAO则完成指定表的crud操作（数据库元素的操作）</p><p>不同的表对应的DAO拥有同一个父类（基本的crud操作），传入泛型</p><p>详见src\com\zjh\dao_\dao</p><p>另外，在DAO层之上，有时程序会同时操作不同的表，这一层组成View层，在View层之上还有Server层。</p><p>@2022&#x2F;9&#x2F;10<br>中秋快乐</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-分而治之</title>
    <link href="/2022/09/06/%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/06/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>时间复杂度分析方法有以下三种：</p><ul><li>递归树法</li><li>代入法</li><li>主定理法</li></ul><h3 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h3><p>以归并排序为例，时间复杂度的递归表达式为<br><img src="/2022-09-07-12-58-45.png"><br>画出该表达式的递归树<br><img src="/2022-09-07-13-00-16.png"><br> →下的若干分叉表示当前节点的复杂度由下属子结点的复杂度组成。则根节点的复杂度等于叶子结点的复杂度之和。即若干O(1)的叶子结点和红色部分的O(n&#x2F;x)之和。</p><p> 递归树的深度（从根节点到最底层）为$log_2 n$，每一层的O(n&#x2F;x)部分相加为n。则红色部分的复杂度相加为$nlog_2 n$</p><p>最底层的黑色叶子结点共有$2^{log_2 n}&#x3D;n$个，每个叶子结点的复杂度为O(1)，所以黑色部分的复杂度相加为$n+nlog_2 n$</p><p>故T(n)&#x3D;O(nlogn)</p><p>类似地，对于下面的复杂度递归式，可做出同样的分析，唯一不同的是该递归树的各个子树的规模不同，为此我们考虑树高最大为$log_{\frac{4}{3}} n+1$，最底层的n&#x2F;x部分相加小于等于n。<br><img src="/2022-09-07-13-24-20.png"><br><img src="/2022-09-07-13-13-54.png"></p><p>故$T(n) \leq nlog_{\frac{4}{3}} n + 2^{log_{\frac{4}{3}} n}  ,T(n)&#x3D;O(nlogn)$</p><p>接下来，思考该界是否为渐进紧确界。引入<strong>代入法</strong>进行说明</p><h3 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h3><p>代入法的主要作用&#x2F;流程是：</p><ul><li>得到算法的时间复杂度递归表达式</li><li>猜测算法的渐进紧确界</li><li>利用数学归纳法进行归纳验证</li></ul><p>以上述的复杂度表达式为例<img src="/2022-09-07-13-24-35.png"><br>猜测算法的渐进紧确界为$T(n)&#x3D;\Theta(nlogn)$，接下来利用数学归纳法进行证明<br><img src="/2022-09-07-13-28-32.png"></p><p>这种方法具有很大的局限性，当猜测解不易得到时我们就需要用到<strong>主定理法</strong>了。</p><h3 id="主定理法"><a href="#主定理法" class="headerlink" title="主定理法"></a>主定理法</h3><p>主定理法关注形如$T(n)&#x3D;aT(\frac{n}{b})+f(n)$的一类递归式。</p><p>首先画出递归树进行分析<br><img src="/2022-09-07-13-33-47.png"><br>树高$log_b n$，最终共产生O(1)的普通叶子结点$a^{log_b n}&#x3D;n^{log_b a}$和常量叶子若干，则可推出T(n)<br><img src="/2022-09-07-13-36-31.png"></p><p>考虑Taylor公式得到主定理如下：<br><img src="/2022-09-07-13-42-55.png"><br>上图所做的比较实际是在衡量分而治之过程中的分解规模带来的影响与递归合并带来的影响之间的平衡。</p><p>特别地，对于$f(n)&#x3D;n^k$的简化情况，主定理可以相应地化简为以下形式（<strong>重要</strong>）</p><p>在某些情况下，落入①②或②③的条件中间，此种情况下可以使用主定理的扩展形式<br><img src="/2022-09-07-13-53-17.png"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>问题：求解数组的非空子数组，使子数组元素之和最大<br><img src="/2022-09-07-13-54-47.png"><br>利用分而治之的思想做出尝试：</p><ul><li>分解问题</li><li>递归求解 </li><li>合并</li></ul><blockquote><p>ps: 下文中提到的最大子数组均指的是最大数值</p></blockquote><p>首先尝试将数组一分为二<br><img src="/2022-09-07-13-56-09.png"><br>接下来考虑递归求解，原数组的最大非空子数组可能的情况有：</p><ol><li>等于原数组左半部分的最大非空子数组</li><li>等于原数组右半部分的最大非空子数组</li><li>横跨原数组的左右半部的数组的最大非空子数组</li></ol><p>分别记数组X左半部分的最大子数组，数组X右半部分的最大子数组，跨越重点的最大子数组为$S_1,S_2,S_3$，则数组X的最大子数组为$S_{max}&#x3D;max{S_1,S_2,S_3}$</p><p>接下来求解$S_3$<br><img src="/2022-09-07-14-03-56.png"></p><p>由此我们完成了分解问题和合并问题，接下来只需进行递归求解，并设置递归退出条件。容易发现，当数组长度为1时可以直接获得最大子数组，由此得到算法如下</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C">MaxSubArray(X,low,high)&#123;<br>    <span class="hljs-comment">//解除递归条件</span><br>    <span class="hljs-keyword">if</span> low==high&#123;<br>        <span class="hljs-keyword">return</span> X[low]<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//分解问题</span><br>        mid &lt;- <span class="hljs-built_in">floor</span>((low+high)/<span class="hljs-number">2</span>)<br>        <span class="hljs-comment">//解决问题</span><br>        S1 &lt;- MaxSubArray(X,low,mid)<br>        S2 &lt;- MaxSubArray(X,mid,+<span class="hljs-number">1</span>,high)<br>        S3 &lt;- CrossingSubArray(X,low,mid,high)<br>        <span class="hljs-comment">//合并问题</span><br>        S_max = max&#123;S1,S2,S3&#125;<br>        <span class="hljs-keyword">return</span> S_max<br>    &#125;<br>&#125;<br><br>CrossingSubArray(X,low,mid,high)&#123;<br>    <span class="hljs-comment">//从中间出发,分别向左和向右出发寻找最大子数组</span><br>    S_left &lt;- -∞<br>    sum &lt;- <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i&lt;- mid downto low &#123;<br>        sum &lt;- sum + X[i]<br>        <span class="hljs-keyword">if</span> sum&gt;S_left&#123;<br>            S_left &lt;- sum<br>        &#125;<br>    &#125;<br>    S_right &lt;- -∞<br>    sum &lt;- <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i&lt;- mid upto high&#123;<br>        sum&lt;- sum+X[i]<br>        <span class="hljs-keyword">if</span> sum&gt;S_right&#123;<br>            S_right &lt;- sum<br>        &#125;<br>    &#125;<br>    S3 &lt;- S_left + S_right<br>    <span class="hljs-keyword">return</span> S3<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cmath<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crossingSubArray</span>(<span class="hljs-params">X,low,mid,high</span>):<br>    s_left = -cmath.inf<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mid,low-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> += X[i]<br>        s_left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">sum</span>,s_left)<br><br>    s_right = -cmath.inf<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mid+<span class="hljs-number">1</span>,high+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">sum</span> += X[i]<br>        s_right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">sum</span>,s_right)<br>    <span class="hljs-keyword">return</span> s_left+s_right<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">X,low,high</span>):<br>    <span class="hljs-comment">#递归退出条件</span><br>    <span class="hljs-keyword">if</span> low == high:<br>        <span class="hljs-comment">#数组长度为1</span><br>        <span class="hljs-keyword">return</span> X[low]<br>    <span class="hljs-keyword">else</span>:<br>        mid = <span class="hljs-built_in">int</span>((low+high)/<span class="hljs-number">2</span>)<br>        s1 = maxSubArray(X,low,mid)<br>        s2 = maxSubArray(X,mid+<span class="hljs-number">1</span>,high)<br>        s3 = crossingSubArray(X,low,mid,high)<br>        s_max = <span class="hljs-built_in">max</span>([s1,s2,s3])<br>        <span class="hljs-built_in">print</span>(X)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; from &quot;</span>,low,<span class="hljs-string">&quot; to &quot;</span>,high,<span class="hljs-string">&quot; maxSubArray= &quot;</span>,s_max)<br>        <span class="hljs-keyword">return</span> s_max<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,-<span class="hljs-number">1</span>]<br>    maxSubArray(<span class="hljs-built_in">list</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>运行结果如图，由输出结果可看出求解过程</p><p><img src="/2022-09-13-10-55-46.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>compiler theory</title>
    <link href="/2022/09/05/compiler-technology/"/>
    <url>/2022/09/05/compiler-technology/</url>
    
    <content type="html"><![CDATA[<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p><img src="/2022-09-08-11-30-08.png"></p><h3 id="输出形式"><a href="#输出形式" class="headerlink" title="输出形式"></a>输出形式</h3><p>词法分析程序将单词按照内部形式输出，有以下几种方案：</p><ol><li>按单词种类分类</li><li>保留字和分界符一符一类</li><li>标识符和常数的单词值作为指示字<br><img src="/2022-09-08-11-34-38.png"><br><img src="/2022-09-08-11-34-58.png"></li></ol><h3 id="（左）正则文法与状态机"><a href="#（左）正则文法与状态机" class="headerlink" title="（左）正则文法与状态机"></a>（左）正则文法与状态机</h3><p><strong>正则文法</strong><br>例如：</p><ul><li>Z::&#x3D;U0|V1</li><li>U::&#x3D;Z1|1</li><li>V::&#x3D;Z0|0<br>正则文法是 型文法</li></ul><p>由正则文法得到对应的<strong>状态图</strong>，其组成成分如下：</p><ul><li>初始状态：空字符串</li><li>状态：非终结符</li><li>触发：终结符</li><li><strong>终止状态</strong>：文法的开始符号</li></ul><p><img src="/2022-09-08-10-28-15.png"></p><p>输入字符串，由空串状态进行字符的读入和分析，在此过程进行状态之间的转换，若最终到达终止状态，则该字符串符合文法的规则。</p><p>上述过程实际是句子从左到右扫描字符向上规约到根节点的过程。（自底向上）</p><blockquote><p>TODO:确定句柄</p></blockquote><h3 id="实现程序"><a href="#实现程序" class="headerlink" title="实现程序"></a>实现程序</h3><p>（简易）状态机如图，词法分析程序所要完成的工作就是读入字符并遍历状态机进行规约<br><img src="/2022-09-08-11-03-45.png"><br>在程序读入过程中存在一个回退的过程：当识别出某一token(x)时，实际多读了一个字符(x&#x3D;)，故需要回退一个字符一遍下一个token的分析判断</p><p>此外还需进行数据结构的建立</p><ul><li>单词和内部表示（名称，类别编码，记忆符，单词值）</li><li>设置词法分析程序所需要的公共变量和过程</li></ul><p><img src="/2022-09-08-11-01-14.png"></p><p>伪代码如下：</p><p><img src="/2022-09-08-11-08-25.png"></p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析的基本功能是从源程序的单词符号串中识别出（句子层面的）语法成分并进行语法检查。</p><p>两大分析方法是自顶向下和自底向上</p><h3 id="自顶向下分析算法"><a href="#自顶向下分析算法" class="headerlink" title="自顶向下分析算法"></a>自顶向下分析算法</h3><p>自顶向下的分析过程是设法建立一颗语法树，使得语法树的末端节点组成目标符号串。分析过程是不断试探的过程，当发现某一推导无法匹配字符串时，需要<strong>回溯</strong>并更换推导所用的规则。</p><p>自顶向下的两个主要问题是<strong>左递归问题</strong>（死循环）和<strong>回溯问题</strong>（效率问题）。</p><h4 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h4><p>消除左递归的方法为</p><ol><li>使用扩充的BNF规则</li><li>改写为右递归</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld</title>
    <link href="/2022/09/04/HelloWorld/"/>
    <url>/2022/09/04/HelloWorld/</url>
    
    <content type="html"><![CDATA[<h1 id="How-to-get-your-own-site"><a href="#How-to-get-your-own-site" class="headerlink" title="How to get your own site"></a>How to get your own site</h1><blockquote><p>一篇通过Hexo部署个人博客的简单总结</p></blockquote><ul><li><a href="#how-to-get-your-own-site">How to get your own site</a><ul><li><a href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</a><ul><li><a href="#git">Git</a><ul><li><a href="#login">login</a></li><li><a href="#ssh%E5%AF%86%E9%92%A5">ssh密钥</a></li><li><a href="#githubio">github.io</a></li></ul></li><li><a href="#node--cnpm--hexo">node &amp; cnpm &amp; hexo</a></li></ul></li><li><a href="#%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5">部署到github个人主页</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91">一些踩过的坑</a></li><li><a href="#references">references</a></li></ul></li></ul></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>在官网下载Git后，依次执行以下命令在本地配置仓库权限</p><h4 id="login"><a href="#login" class="headerlink" title="login"></a>login</h4><p>进入Git bash</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;你注册时的用户名&quot;</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;注册时的邮箱&quot;</span><br></code></pre></td></tr></table></figure><h4 id="ssh密钥"><a href="#ssh密钥" class="headerlink" title="ssh密钥"></a>ssh密钥</h4><p>在Git Bash中输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cd ~/.ssh<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your email&quot;</span><br>cat id_rsa.pub <span class="hljs-string">&quot;copy it&quot;</span><br></code></pre></td></tr></table></figure><p>来到Github个人页面的<code>setting-&gt;Deploy keys-&gt;Add deploy key-&gt;key</code>，粘贴刚刚复制的ssh密钥，title随便填<br><img src="/2022-09-05-00-04-37.png"></p><h4 id="github-io"><a href="#github-io" class="headerlink" title="github.io"></a>github.io</h4><p>新建一个名为yourname.github.io的仓库</p><h3 id="node-amp-cnpm-amp-hexo"><a href="#node-amp-cnpm-amp-hexo" class="headerlink" title="node &amp; cnpm &amp; hexo"></a>node &amp; cnpm &amp; hexo</h3><p><a href="https://nodejs.org/en/download/">node.js</a>官网安装nodejs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">node -v <span class="hljs-comment">#查看版本/是否安装成功</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">npm install -g cnpm --registry==https://registry.npm.taobao.org <br><span class="hljs-comment"># 安装cnpm</span><br>cnpm -v<br><span class="hljs-comment"># 查看版本/是否安装成功</span><br>cnpm install -g hexo-clicnpm install -g hexo-cli<br><span class="hljs-comment"># 安装hexo</span><br>hexo -v<br><span class="hljs-comment"># 查看版本/是否安装成功 </span><br>mkdir Blog<br><span class="hljs-comment"># 新建博客文件夹，可以在任何位置</span><br>hexo init<br><span class="hljs-comment"># 初始化hexo</span><br>hexo g<br><span class="hljs-comment"># 生成</span><br>hexo s<br><span class="hljs-comment"># 启动服务，本地预览</span><br></code></pre></td></tr></table></figure><h2 id="部署到github个人主页"><a href="#部署到github个人主页" class="headerlink" title="部署到github个人主页"></a>部署到github个人主页</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下载hexo-deployer-git插件</span><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改<code>Blog\_config.yml</code>文件配置为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: github上对应仓库的ssh 链接              <br>  branch: main<br></code></pre></td></tr></table></figure><p>之后将本地博客推送到github仓库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hexo d <br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li>新建md文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">hexo new <span class="hljs-string">&quot;title&quot;</span><br><span class="hljs-comment">#文件位于Blog\source\_posts</span><br></code></pre></td></tr></table></figure></li><li>新建其他文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一般是页面配置的一些文件</span><br>hexo new page <span class="hljs-string">&quot;about&quot;</span><br></code></pre></td></tr></table></figure></li><li>删除文章<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">rm Blog\_post\target.md<br>hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>hexo d可能会有点慢，耐心等下就好了</li><li>本地预览<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hexo s<br></code></pre></td></tr></table></figure></li></ol><h3 id="一些踩过的坑"><a href="#一些踩过的坑" class="headerlink" title="一些踩过的坑"></a>一些踩过的坑</h3><ol><li>要记得配ssh密钥（<del>一直以来只配了oo账号的ssh(×)</del>)，否则会在<code>hexo d</code>的时候出现permission denied</li><li>npm下载插件速度慢，卡在sill idealTree buildDeps<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> 打开cmd 配置淘宝镜像<br>npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br><br><span class="hljs-number">2.</span> 关闭上面cmd, 打开一个新的cmd 安装vue/cli(之前在一个cmd连续执行,总会卡死)<br>npm install -g @vue/cli<br></code></pre></td></tr></table></figure></li></ol><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><ol><li><a href="https://blog.csdn.net/weixin_42490383/article/details/125895180">https://blog.csdn.net/weixin_42490383/article/details/125895180</a></li><li><a href="https://blog.csdn.net/ItDaChuang/article/details/111261426">https://blog.csdn.net/ItDaChuang/article/details/111261426</a></li><li><a href="https://blog.csdn.net/qq_44732432/article/details/124714408">https://blog.csdn.net/qq_44732432/article/details/124714408</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
